<!doctype html>
<!--
 VHDR — CodingAgent Companion — index.html
 Version: v1.0.0  |  Build: 2025-09-24  Europe/Warsaw
 Purpose: Local HTML5 app to assemble one-shot coding prompts and apply AI patches without APIs.
 Changelog (latest first):
 - v1.0.0: Initial release (prompt builder, folder ingest, token estimate, repo fence parser, diffs, FS writes).
-->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CodingAgent Companion — One-Shot Builder (No API)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html,body{margin:0;padding:0;font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0b0e12;color:#e9eef6}
    a{color:#9ad} button{cursor:pointer}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:0 0 12px}
    .grid{display:grid;gap:12px}
    @media (min-width:900px){.grid{grid-template-columns:1.1fr 1fr}}
    .card{background:#131a22;border:1px solid #1f2a35;border-radius:14px;padding:12px;box-shadow:0 0 0 1px #0e141a inset}
    label{display:block;margin:6px 0 4px;color:#c8d3df}
    input[type=text],input[type=number],textarea,select{
      width:100%;box-sizing:border-box;background:#0e141a;border:1px solid #253242;border-radius:10px;color:#e9eef6;
      padding:10px 12px;font:14px/1.4 inherit;outline:none
    }
    textarea{min-height:120px;resize:vertical}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .row>div{flex:1}
    .btn{background:#1e90ff;border:0;border-radius:10px;padding:10px 12px;color:#fff;font-weight:600}
    .btn.secondary{background:#2b3948}
    .btn.ghost{background:transparent;border:1px solid #2b3948;color:#c8d3df}
    .mono{font-family:ui-monospace,SFMono-Regular,Consolas,Menlo,monospace}
    .small{font-size:12px;color:#a9b4c0}
    .pill{display:inline-block;border:1px solid #2b3948;border-radius:999px;padding:2px 8px;margin-right:6px}
    .ok{color:#83e377}.warn{color:#ffd166}.bad{color:#ff6b6b}
    .files{max-height:180px;overflow:auto;border:1px dashed #2b3948;border-radius:10px;padding:8px}
    .drop{border:2px dashed #425a74;border-radius:12px;padding:12px;text-align:center;color:#a9b4c0}
    .cols{display:grid;gap:10px}
    @media (min-width:900px){.cols{grid-template-columns:1fr 1fr}}
    pre.code{white-space:pre-wrap;background:#0e141a;border:1px solid #253242;border-radius:10px;padding:10px;max-height:320px;overflow:auto}
    details summary{cursor:pointer}
    .diff{white-space:pre-wrap;background:#0e141a;border:1px solid #314154;border-radius:10px;padding:10px}
    .add{background:#0b2e16} .del{background:#3a1111}
    .filelist{max-height:240px;overflow:auto}
    .tag{background:#233040;border-radius:8px;padding:2px 6px;margin:0 4px 4px 0;display:inline-block}
  </style>
</head>
<body>
<div class="wrap">
  <h1>⚙️ CodingAgent Companion — One-Shot Builder (No API)</h1>
  <div class="grid">
    <div class="card">
      <h3>1) Project & Task</h3>
      <div class="row">
        <div><label>Project Name</label><input id="proj" type="text" placeholder="DoAndroidsTrain"></div>
        <div><label>License</label>
          <select id="license">
            <option>MIT</option><option>Apache-2.0</option><option>Proprietary</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div><label>Task Title</label><input id="title" type="text" placeholder="HTML5 Affirmations App vNext"></div>
        <div><label>Output Language</label>
          <select id="outlang"><option>en</option><option>de</option><option>nl</option><option>pl</option></select>
        </div>
      </div>
      <label>Objective (2–4 sentences)</label>
      <textarea id="objective" placeholder="What to build/fix and why..."></textarea>
      <div class="row">
        <div><label>Requirement 1</label><input id="req1" type="text" placeholder="Play/pause, per-voice FX"></div>
        <div><label>Requirement 2</label><input id="req2" type="text" placeholder="Echo/reverb routing"></div>
      </div>
      <div class="row">
        <div><label>Non-functional Target</label><input id="nfr" type="text" placeholder="LCP &lt; 2.5s, WCAG AA"></div>
        <div><label>ESLint warnings ≤</label><input id="warncap" type="number" min="0" value="0"></div>
      </div>
      <div class="row">
        <div><label>Dev Port (Frontend)</label><input id="devport" type="number" value="5173"></div>
        <div><label>API Port (Backend)</label><input id="apiport" type="number" value="3000"></div>
      </div>
    </div>

    <div class="card">
      <h3>2) Source Files (pick folder or drop)</h3>
      <div class="row">
        <input id="dirpick" type="file" webkitdirectory multiple>
        <input id="filepick" type="file" multiple>
      </div>
      <div id="drop" class="drop">Drag & Drop files here</div>
      <div class="small">Included files:</div>
      <div id="filelist" class="files mono"></div>
      <div class="small">Approx. token estimate: <span id="tok" class="pill">0</span></div>
    </div>

    <div class="card">
      <h3>3) Build One-Shot Prompt</h3>
      <button id="build" class="btn">Build Prompt</button>
      <button id="copy" class="btn secondary">Copy Prompt</button>
      <button id="openchat" class="btn ghost" title="Opens ChatGPT in a new tab">Open ChatGPT</button>
      <p class="small">Workflow: Build → Copy → Paste into a new Chat → Wait for AI → Paste AI output below to review/apply.</p>
      <label>Generated Prompt</label>
      <pre id="prompt" class="code mono"></pre>
    </div>

    <div class="card">
      <h3>4) Paste AI Output (repo fence)</h3>
      <textarea id="aiout" class="mono" placeholder="Paste the assistant's output that contains ```repo ...```"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="parse" class="btn">Parse & Diff</button>
        <button id="pickwrite" class="btn secondary" title="Grant write access to a folder for applying changes">Choose Target Folder</button>
      </div>
      <div id="parseStatus" class="small"></div>
      <details open>
        <summary>Changed / New Files</summary>
        <div id="changes" class="filelist"></div>
      </details>
    </div>

    <div class="card">
      <h3>5) Apply Selected Changes</h3>
      <div class="small">Select files below and click <b>Apply</b>. If your browser blocks direct writes, use <i>Download</i> per file.</div>
      <div class="row" style="margin:8px 0">
        <button id="apply" class="btn">Apply Selected</button>
        <button id="applyAll" class="btn secondary">Apply All</button>
      </div>
      <div id="applyStatus" class="small"></div>
      <div id="diffview" class="diff mono" style="margin-top:10px"></div>
    </div>
  </div>

  <p class="small">Tip: This app uses the File System Access API where available (Chrome/Edge). Otherwise, download updated files individually.</p>
</div>

<script>
/* VHDR — CodingAgent Companion — app.js (inline)
 * Version: v1.0.0  |  Build: 2025-09-24  Europe/Warsaw
 * Purpose: Logic for prompt assembly, file ingest, repo fence parsing, diffs, and writes.
 * Changelog:
 * - v1.0.0: Initial.
 */
(() => {
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const state = {
    files: new Map(),        // path -> {name, path, content, lang}
    aiFiles: new Map(),      // parsed from AI repo fence
    writeDir: null           // FileSystemDirectoryHandle
  };

  // --- UI refs
  const out = {
    list: $("#filelist"),
    tok: $("#tok"),
    prompt: $("#prompt"),
    parseStatus: $("#parseStatus"),
    changes: $("#changes"),
    diffview: $("#diffview"),
    applyStatus: $("#applyStatus")
  };

  // --- Helpers
  const extToLang = (name) => {
    const ext = name.split(".").pop().toLowerCase();
    const map = {html:"html",htm:"html",css:"css",js:"javascript",mjs:"javascript",cjs:"javascript",
                 ts:"typescript",tsx:"typescript",jsx:"javascript",json:"json",md:"markdown",
                 yml:"yaml",yaml:"yaml",svg:"xml"};
    return map[ext] || "text";
  };
  const estimateTokens = (text) => Math.ceil(text.replace(/\s+/g,' ').length / 4); // rough 4 chars/token

  const addFiles = async (fileList) => {
    for (const f of fileList) {
      if (!f || !f.name) continue;
      const path = f.webkitRelativePath && f.webkitRelativePath.length ? f.webkitRelativePath : f.name;
      const content = await f.text();
      state.files.set(path, { name: f.name, path, content, lang: extToLang(f.name) });
    }
    renderFileList();
    updateTokenEstimate();
  };

  const renderFileList = () => {
    const lines = [];
    for (const [p, meta] of state.files.entries()) {
      lines.push(p + "  (" + meta.content.length + " chars)");
    }
    out.list.textContent = lines.length ? lines.join("\n") : "(none)";
  };

  const buildPromptText = () => {
    const get = id => $(id).value.trim();
    const proj = get("#proj") || "MyProject";
    const license = get("#license");
    const title = get("#title") || "Task";
    const objective = get("#objective") || "Build/Refactor.";
    const req1 = get("#req1") || "Requirement A";
    const req2 = get("#req2") || "Requirement B";
    const nfr = get("#nfr") || "Reasonable performance & UX";
    const warncap = get("#warncap") || "0";
    const devport = get("#devport") || "5173";
    const apiport = get("#apiport") || "3000";
    const outlang = get("#outlang");

    const filesSection = [];
    for (const [path, meta] of state.files.entries()) {
      filesSection.push(`<<<FILE path="${path}" lang="${meta.lang}">`);
      filesSection.push(meta.content);
      filesSection.push("<<<END FILE>>>");
    }

    const prompt =
`===== HFS-OSCAP v1.0.0 — HTML5 Full-Stack One-Shot Coding Agent =====
meta:
  model_pref: "GPT-5 Thinking"
  timezone: "Europe/Warsaw"
  default_language: "${outlang}"
  author: "Atlas User"
  prompt_version: "v1.0.0"
  run_date: "${new Date().toISOString().slice(0,10)}"

project:
  name: "${proj}"
  stack:
    frontend: ["HTML5","CSS3","TypeScript","Vite"]
    backend: ["Node.js 20 LTS","Express 4.x"]
    testing: ["Vitest"]
    quality: ["ESLint","Prettier","TypeCheck (tsc --noEmit)"]
  target_env: ["browser","node"]
  license: "${license}"

task:
  title: "${title}"
  objective: >
    ${objective}
  requirements:
    - "${req1}"
    - "${req2}"
    - "${nfr}"
  acceptance_tests:
    - "Given idle, when user interacts, then deterministic results."
    - "Frontend builds with \`npm run build\`."
    - "Backend healthcheck 200 on /healthz."
    - "Unit tests pass: \`npm test\`."
  deliverables:
    - "COMPLETE REPO inside one code-fence (see OUTPUT CONTRACT)."
    - "README with Quickstart."
    - "Automated tests."
    - "CHANGELOG.md + per-file VHDR."
    - "Complexity & risk notes."

constraints:
  comments_policy: "Minimal—only VHDR + essential TODOs."
  version_header:
    pattern: |
      /*
       * VHDR — ${proj} — <RELATIVE_PATH>
       * Version: <semver>  |  Build: ${new Date().toISOString().slice(0,16).replace('T',' ')} Europe/Warsaw
       * Purpose: <one-line purpose>
       * Changelog (latest first):
       * - <semver>: <concise change>
       * - <prev>: <prior change>
       */
  deps:
    allowed: ["zod","dayjs"]
    forbidden: ["eval","Function"]
  security:
    - "No secrets/hardcoding; use env."
    - "Validate & sanitize inputs."
    - "CSP (frontend), helmet (backend)."
  quality_gates:
    - "ESLint: no errors; warnings <= ${warncap}."
    - "Prettier formatted."
    - "TypeScript: no errors."
  syntax_gate:
    - "Repo must be syntactically valid and runnable."
  accessibility: "WCAG 2.1 AA basics."

output_contract:
  order:
    - "TLDR_MULTILINGUAL"
    - "1) Direct Answer"
    - "2) How It’s Done"
    - "3) Alternatives"
    - "4) Action Plan"
    - "--- ARTIFACTS START ---"
    - "\`\`\`repo ... (files) ... \`\`\`"
    - "--- ARTIFACTS END ---"
  repo_fence: "\`\`\`repo"
  file_markers:
    start: "// FILE: <path> [lang=<language>]"
    end: "// END FILE"
  notes:
    - "Emit a complete, runnable repository with scripts."
    - "Use minimal comments beyond VHDR."
    - "If fixing bugs, also include an MRE under tests/."

FILES:
${filesSection.join("\n") || "  # (none provided)"}

EXECUTION_REQUEST:
  output_language: "${outlang}"
  verbosity: "concise"
  test_framework: "vitest"
  dev_server_port: ${devport}
  api_port: ${apiport}
  build_command: "npm run build"
  run_command: "npm run dev && npm run dev:server"
  test_command: "npm test"

FINAL_INSTRUCTIONS:
  - "Honor OUTPUT CONTRACT strictly."
  - "Every file begins with a VHDR block and a mini-changelog."
  - "Keep inline comments minimal elsewhere."
  - "Emit the complete repo inside a single \`\`\`repo code fence using file markers."
  - "After artifacts, stop."
===== END HFS-OSCAP =====`;
    return prompt;
  };

  const updateTokenEstimate = () => {
    const promptPreview = buildPromptText();
    const tokens = estimateTokens(promptPreview);
    out.tok.textContent = tokens.toLocaleString();
  };

  // --- Diff (simple LCS line diff)
  const diffLines = (a, b) => {
    const A = a.split(/\r?\n/), B = b.split(/\r?\n/);
    const n=A.length, m=B.length;
    const dp = Array(n+1).fill(0).map(()=>Array(m+1).fill(0));
    for(let i=1;i<=n;i++) for(let j=1;j<=m;j++) dp[i][j]=A[i-1]===B[j-1]?dp[i-1][j-1]+1:Math.max(dp[i-1][j],dp[i][j-1]);
    const ops=[];
    let i=n,j=m;
    while(i>0||j>0){
      if(i>0&&j>0&&A[i-1]===B[j-1]){ ops.push([" ",A[i-1]]); i--; j--; }
      else if(j>0 && (i===0 || dp[i][j-1]>=dp[i-1][j])){ ops.push(["+",B[j-1]]); j--; }
      else { ops.push(["-",A[i-1]]); i--; }
    }
    return ops.reverse();
  };

  // --- Repo fence parser
  const parseRepoFence = (text) => {
    const fenceMatch = text.match(/```repo([\s\S]*?)```/);
    if(!fenceMatch) return { ok:false, msg:"No ```repo fence found." };
    const block = fenceMatch[1];
    const fileRE = /\/\/ FILE:\s*(.+?)(?:\s+\[lang=([^\]]+)\])?[\r\n]+([\s\S]*?)\n\/\/ END FILE/g;
    const results = new Map();
    let m;
    while((m=fileRE.exec(block))!==null){
      const path = m[1].trim();
      const lang = (m[2]||"text").trim();
      const content = m[3];
      results.set(path,{path,lang,content});
    }
    return results.size?{ok:true,files:results}:{ok:false,msg:"No files found inside repo fence."};
  };

  const renderChanges = () => {
    out.changes.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const [path, ai] of state.aiFiles.entries()) {
      const orig = state.files.get(path)?.content || "";
      const ops = diffLines(orig, ai.content);
      const changed = ops.some(op => op[0] !== " ");
      const div = document.createElement("div");
      div.className = "card";
      div.style.background="#0e141a";
      div.innerHTML = `
        <div class="row" style="align-items:center">
          <input type="checkbox" data-path="${path}" ${changed?"checked":""}>
          <div style="flex:1"><b>${path}</b> ${changed?'<span class="pill warn">changed</span>':'<span class="pill ok">new/unchanged</span>'}
            <span class="tag">lang=${ai.lang}</span>
            <button class="btn ghost" data-show="${path}">Show Diff</button>
            <button class="btn ghost" data-dl="${path}">Download</button>
          </div>
        </div>`;
      frag.appendChild(div);
    }
    out.changes.appendChild(frag);

    out.changes.addEventListener("click", (e) => {
      const t = e.target;
      if (t.dataset.show) {
        const p = t.dataset.show;
        const orig = state.files.get(p)?.content || "";
        const next = state.aiFiles.get(p)?.content || "";
        const ops = diffLines(orig,next).map(([k,l]) => (k==="+"?`+ ${l}`:k==="-"?`- ${l}`:`  ${l}`)).join("\n");
        out.diffview.innerHTML = ops
          .replace(/^(\+ .*)$/gm,'<span class="add">$1</span>')
          .replace(/^(\- .*)$/gm,'<span class="del">$1</span>');
      }
      if (t.dataset.dl) {
        const p = t.dataset.dl;
        const blob = new Blob([state.aiFiles.get(p).content], {type:"text/plain"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = p.split("/").pop();
        a.click();
        URL.revokeObjectURL(a.href);
      }
    }, { once: true });
  };

  // --- File writes
  const ensureDir = async (dirHandle, path) => {
    const parts = path.split("/"); parts.pop();
    let cur = dirHandle;
    for (const folder of parts) {
      if (!folder) continue;
      cur = await cur.getDirectoryHandle(folder, { create:true });
    }
    return cur;
  };

  const writeFile = async (dirHandle, path, content) => {
    const dir = await ensureDir(dirHandle, path);
    const name = path.split("/").pop();
    const fileHandle = await dir.getFileHandle(name, { create:true });
    const ws = await fileHandle.createWritable();
    await ws.write(content);
    await ws.close();
  };

  // --- Event wiring
  $("#dirpick").addEventListener("change", e => addFiles(e.target.files));
  $("#filepick").addEventListener("change", e => addFiles(e.target.files));
  const drop = $("#drop");
  drop.addEventListener("dragover", e => { e.preventDefault(); drop.style.background="#0c1520"; });
  drop.addEventListener("dragleave", e => { drop.style.background=""; });
  drop.addEventListener("drop", async e => {
    e.preventDefault(); drop.style.background="";
    if (e.dataTransfer.items) {
      const files = [];
      for (const item of e.dataTransfer.items) {
        const entry = item.webkitGetAsEntry && item.webkitGetAsEntry();
        if (entry && entry.isDirectory) {
          // Traverse directory
          await new Promise(resolve => {
            const reader = entry.createReader();
            const walk = () => reader.readEntries(async entries => {
              if (!entries.length) return resolve();
              for (const ent of entries) {
                if (ent.isFile) {
                  await new Promise(res => ent.file(f => { f.webkitRelativePath = ent.fullPath.slice(1); files.push(f); res(); }));
                } else if (ent.isDirectory) {
                  const r = ent.createReader(); const walk2 = () => r.readEntries(async es => {
                    if (!es.length) return;
                    for (const e2 of es) {
                      if (e2.isFile) await new Promise(res => e2.file(f=>{ f.webkitRelativePath=e2.fullPath.slice(1); files.push(f); res(); }));
                      else { /* nested dir */ const r2=e2.createReader(); r2.readEntries(()=>{}); }
                    }
                    walk2();
                  }); walk2();
                }
              }
              walk();
            });
          });
          await addFiles(files);
        } else {
          const f = item.getAsFile && item.getAsFile();
          if (f) await addFiles([f]);
        }
      }
    } else if (e.dataTransfer.files) {
      await addFiles(e.dataTransfer.files);
    }
  });

  $("#build").addEventListener("click", () => {
    out.prompt.textContent = buildPromptText();
    updateTokenEstimate();
  });

  $("#copy").addEventListener("click", async () => {
    const txt = out.prompt.textContent || buildPromptText();
    await navigator.clipboard.writeText(txt);
    alert("Prompt copied to clipboard.");
  });

  $("#openchat").addEventListener("click", () => {
    window.open("https://chat.openai.com", "_blank");
  });

  $("#parse").addEventListener("click", () => {
    const raw = $("#aiout").value;
    const parsed = parseRepoFence(raw);
    if (!parsed.ok) { out.parseStatus.innerHTML = `<span class="bad">Parse error:</span> ${parsed.msg}`; return; }
    state.aiFiles = parsed.files;
    out.parseStatus.innerHTML = `<span class="ok">Parsed ${parsed.files.size} files.</span>`;
    renderChanges();
  });

  $("#pickwrite").addEventListener("click", async () => {
    if (!window.showDirectoryPicker) { alert("File System Access API not supported in this browser."); return; }
    state.writeDir = await window.showDirectoryPicker({ mode:"readwrite" });
    out.applyStatus.innerHTML = `<span class="ok">Write access granted.</span>`;
  });

  const collectSelected = () => {
    const selected = [];
    $$("#changes input[type=checkbox]").forEach(cb => { if (cb.checked) selected.push(cb.dataset.path); });
    return selected;
  };

  $("#apply").addEventListener("click", async () => {
    if (!state.writeDir) { alert("Choose a target folder first."); return; }
    const paths = collectSelected();
    if (!paths.length) { alert("No files selected."); return; }
    for (const p of paths) await writeFile(state.writeDir, p, state.aiFiles.get(p).content);
    out.applyStatus.innerHTML = `<span class="ok">Applied ${paths.length} file(s).</span>`;
  });

  $("#applyAll").addEventListener("click", async () => {
    if (!state.writeDir) { alert("Choose a target folder first."); return; }
    let count=0;
    for (const [p, file] of state.aiFiles.entries()) { await writeFile(state.writeDir, p, file.content); count++; }
    out.applyStatus.innerHTML = `<span class="ok">Applied ${count} file(s).</span>`;
  });

})();
</script>
</body>
</html>
