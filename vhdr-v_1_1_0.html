<!--
  VHDR — 3D Map — single-file.html
  Version: 1.1.0  |  Build: 2025-09-24 18:35 Europe/Warsaw
  Purpose: Single-file HTML app: OSM → Overpass → THREE.js 3D buildings with gyro calibration.
  Changelog (latest first):
  - 1.1.0: Single-file edition (client-only; Overpass direct; inline UI/styles).
  - 1.0.0: Full-stack prototype (Vite + Express) with tests and quality gates.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Map — Single File</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--bg:#0b1020;--fg:#e7ecf5;--muted:#a9b3c7;--accent:#66d9ff;--panel:#121a33;--btn:#1b274a;--btnh:#23335f}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.3 system-ui,Segoe UI,Roboto,Ubuntu,Arial;}
    .app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
    .bar{display:flex;gap:.5rem;align-items:center;padding:.5rem .75rem;background:var(--panel);border-bottom:1px solid #223}
    .bar h1{margin:0 .5rem 0 0;font-size:1rem}
    .sp{flex:1}
    button,input{background:var(--btn);color:var(--fg);border:1px solid #2a3a66;border-radius:.375rem;padding:.35rem .6rem}
    button:hover{background:var(--btnh);cursor:pointer}
    button:focus,input:focus{outline:2px solid var(--accent);outline-offset:2px}
    #c3d{width:100%;height:100%;display:block}
    .status{position:absolute;left:.75rem;bottom:.75rem;background:rgba(18,26,51,.82);padding:.45rem .6rem;border-radius:.4rem;color:var(--muted);font-size:.82rem}
  </style>
</head>
<body>
  <div class="app" aria-live="polite">
    <div class="bar" role="toolbar" aria-label="Controls">
      <h1>3D Map</h1>
      <span id="loc" aria-label="Location source">Locating…</span>
      <div class="sp"></div>
      <label for="radius">Radius (m)</label>
      <input id="radius" type="number" min="50" max="1000" step="50" value="300" />
      <button id="reload" aria-label="Reload area">Reload</button>
      <button id="gyro" aria-label="Enable gyroscope">Enable Gyro</button>
      <button id="cal" aria-label="Calibrate heading">Calibrate</button>
    </div>
    <canvas id="c3d" aria-label="3D map canvas"></canvas>
    <div class="status" id="st">Ready</div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    const DEFAULT = { lat: 50.06143, lon: 19.93658 }; // Kraków
    const OVERPASS = "https://overpass-api.de/api/interpreter";
    const M_PER_DEG = 111320;

    const $ = (id)=>document.getElementById(id);
    const elLoc = $("loc"), elSt = $("st"), elCanvas = $("c3d");
    const elRadius = $("radius"), btnReload = $("reload"), btnGyro = $("gyro"), btnCal = $("cal");

    function now(){ const d=new Date(); return d.toTimeString().slice(0,8); }
    function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

    function toLocalMeters(origin, pt){
      const phi = origin.lat * Math.PI/180;
      return {
        x: (pt.lon - origin.lon) * Math.cos(phi) * M_PER_DEG,
        y: (pt.lat - origin.lat) * M_PER_DEG
      };
    }

    function parseMeters(raw){
      if(!raw) return undefined;
      const m = String(raw).trim().toLowerCase().match(/^([0-9]+(?:\.[0-9]+)?)\s*m?$/);
      return m ? Number(m[1]) : undefined;
    }
    function parseLevels(raw){
      if(!raw) return undefined;
      const m = String(raw).trim().match(/^([0-9]+(?:\.[0-9]+)?)$/);
      return m ? Number(m[1]) : undefined;
    }
    function computeHeightMeters(tags){
      const h = parseMeters(tags?.height);
      if(Number.isFinite(h) && h>0) return h;
      const lv = parseLevels(tags?.["building:levels"]);
      if(Number.isFinite(lv) && lv>0) return lv*3;
      return 10;
    }

    async function getPosition(){
      return new Promise((res)=>{
        if(!("geolocation" in navigator)) return res({ ...DEFAULT, source:"default" });
        navigator.geolocation.getCurrentPosition(
          (p)=>res({ lat:p.coords.latitude, lon:p.coords.longitude, source:"gps" }),
          ()=>res({ ...DEFAULT, source:"default" }),
          { enableHighAccuracy:true, timeout:8000, maximumAge:60000 }
        );
      });
    }

    function buildOverpass(lat, lon, radius){
      return `
        [out:json][timeout:25];
        (
          way["building"](around:${radius},${lat},${lon});
        );
        out geom tags;
      `;
    }

    async function fetchBuildings(lat, lon, radius){
      const r = await fetch(OVERPASS, {
        method:"POST",
        headers:{ "Content-Type":"text/plain", "Accept":"application/json" },
        body: buildOverpass(lat,lon,radius)
      });
      if(!r.ok) throw new Error("Overpass error "+r.status);
      const json = await r.json();
      const ways = (json.elements||[]).filter(e=>e.type==="way" && Array.isArray(e.geometry) && e.geometry.length>=3);
      const out = [];
      for(const w of ways){
        const fp = w.geometry.slice();
        const first = fp[0], last = fp[fp.length-1];
        if(first.lat!==last.lat || first.lon!==last.lon) fp.push(first);
        const h = computeHeightMeters(w.tags||{});
        if(h<=0) continue;
        out.push({ id:w.id, height:h, footprint:fp.map(p=>({lat:p.lat, lon:p.lon})) });
      }
      return out;
    }

    class Scene {
      constructor(canvas){
        this.canvas = canvas;
        this.renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
        this.renderer.setPixelRatio(Math.min(devicePixelRatio,2));
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0b1020);
        this.camera = new THREE.PerspectiveCamera(60, 1, 0.1, 5000);
        this.camera.position.set(0,200,300);
        const amb = new THREE.AmbientLight(0xffffff, .6);
        const sun = new THREE.DirectionalLight(0xffffff, .8); sun.position.set(200,400,100);
        this.scene.add(amb,sun);
        const ground = new THREE.Mesh(
          new THREE.PlaneGeometry(2000,2000),
          new THREE.MeshStandardMaterial({ color:0x1b274a, roughness:.95, metalness:0 })
        );
        ground.rotation.x = -Math.PI/2;
        this.scene.add(ground);
        this.root = new THREE.Group(); this.scene.add(this.root);
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;

        this.yawOffset = 0; this.currentYaw = 0; this.gyroOn = false;

        addEventListener("resize",()=>this.resize());
        this.resize();
        this.loop();
      }
      resize(){
        const w = this.canvas.clientWidth || innerWidth;
        const h = this.canvas.clientHeight || innerHeight;
        this.renderer.setSize(w,h,false);
        this.camera.aspect = w/h; this.camera.updateProjectionMatrix();
      }
      reset(buildings){
        this.root.clear();
        const mat = new THREE.MeshStandardMaterial({ color:0x66d9ff, roughness:.7, metalness:.1 });
        let cx=0, cz=0, n=0;
        for(const b of buildings){
          const shape = new THREE.Shape();
          b.points.forEach((p,i)=>{ if(i===0) shape.moveTo(p.x,p.y); else shape.lineTo(p.x,p.y); });
          shape.autoClose = true;
          const geom = new THREE.ExtrudeGeometry(shape, { depth:b.height, bevelEnabled:false });
          geom.rotateX(-Math.PI/2);
          const mesh = new THREE.Mesh(geom, mat);
          this.root.add(mesh);
          const p0 = b.points[0]; cx+=p0.x; cz+=p0.y; n++;
        }
        if(n>0){
          cx/=n; cz/=n;
          this.controls.target.set(cx,0,cz);
          this.camera.position.set(cx+250,180,cz+250);
          this.controls.update();
        }
      }
      async enableGyro(){
        const DOE = window.DeviceOrientationEvent;
        const need = typeof DOE?.requestPermission === "function";
        if(need){
          try{ const perm = await DOE.requestPermission(); if(perm!=="granted") return; } catch{ return; }
        }
        this.gyroOn = true;
        addEventListener("deviceorientation",(ev)=>{
          if(typeof ev.alpha === "number"){ this.currentYaw = ev.alpha * Math.PI/180; }
        }, { passive:true });
      }
      calibrate(){ this.yawOffset = this.currentYaw; }
      applyGyro(){
        if(this.gyroOn && this.currentYaw){ this.scene.rotation.y = -(this.currentYaw - this.yawOffset); }
      }
      loop=()=>{
        requestAnimationFrame(this.loop);
        this.applyGyro();
        this.controls.update();
        this.renderer.render(this.scene,this.camera);
      }
    }

    const scene = new Scene(elCanvas);
    let origin = null;

    async function loadAndRender(center, radius){
      elSt.textContent = "Loading buildings…";
      try{
        const list = await fetchBuildings(center.lat, center.lon, radius);
        const proj = list.map(b=>({
          id:b.id,
          height:b.height,
          points: b.footprint.map(p=>toLocalMeters(center, p))
        })).filter(b=>b.points.length>=3 && b.height>0.1);
        scene.reset(proj);
        elSt.textContent = `Loaded ${proj.length} • ${now()}`;
      }catch(e){
        elSt.textContent = "Overpass failed. Try smaller radius / later.";
      }
    }

    (async function init(){
      const loc = await getPosition();
      origin = { lat: loc.lat, lon: loc.lon };
      elLoc.textContent = loc.source==="gps" ? "GPS" : "Default: Kraków";
      await loadAndRender(origin, Number(elRadius.value)||300);
    })();

    btnReload.addEventListener("click", ()=>{
      const r = clamp(parseInt(elRadius.value||"300",10), 50, 1000);
      elRadius.value = String(r);
      loadAndRender(origin||DEFAULT, r);
    });
    btnGyro.addEventListener("click", ()=>{ scene.enableGyro(); });
    btnCal.addEventListener("click", ()=>{ scene.calibrate(); });
  </script>
</body>
</html>
